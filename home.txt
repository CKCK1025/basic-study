===============有赞======================
1面：
1. 选择器，以及选择器优先级
!important--->内联-->id--->类/属性/伪类--->元素/伪元素--->关系选择器/通配符选择器



2. 谈谈bfc
是什么：块级格式上下文，一个独立环境，容器这个块box中的布局与容器外的毫无相关。
触发条件：根元素html;
        float值不为none;
        overflow值不为visible,display值为inline-block,table-cell,table-caption;
        position值为absolute或者fixed
特别作用：可以阻止元素被浮动元素覆盖
        可以包含浮动元素
        同个bfc下两个元素会margin重叠，两个不同bfc下的元素margin不会重叠



3. 盒模型
w3c:
width = contentW,
ie情况： width = contentw+border+padding(box-sizing: border-box)



4. 左固定，右适应布局
float:left + margin
calc
float + overflow(开启bfc)
利用flex实现:width + flex:1 



5. 关于跨域
限制一个源的文档或者它加载的脚本如何与另一个源进行交互，即同源策略限制，协议，ip-域名，端口;
无同源策略，接口请求，DOM查询。

我遇到的JSONP,cors,Nginx，postMessage

JSONP只能get,
实现JSONP: 定义获取跨域响应数据的回调函数，并通过没有同源策略限制的script标签发起请求，然后服务端返回该回调函数的执行，并将数据带入回调函数。
JSONP风险：
csrf攻击：将一个网站隐私cookie携带到另外一个网站，被盗取。cookie机制，后端可以设置httpOnly，前端不可操作cookie；
xss漏洞：获取目标网站DOM，盗用信息。（严格定义content-type:application/json,过滤callback参数，进行字符转义，防止脚本    ）

cors:跨域资源共享
1,浏览器请求头加origin
2,服务端配置，Access-Control-Allow-Methods,Access-Control-Allow-Headers,Access-Control-Allow-Origin;指定可访问的方法，头部，源信息
3，请求分为简单和非简单，非简单会先进行探针option方法进行预检，判断是否允许当前跨域请求。

Access-Control-Allow-Origin：要么请求的origin字段，要么*通配符
Access-Control-Allow-Credentials: 是否允许携带cookie
Access-Control-Expose-Headers: cors请求，XMLHttpRequest对象只能拿catch-control,content-language,content-type,expires,last-modifyed,pragma;其他请求头需要单独配置。

postMessage: 
iframe页面嵌入，ifram页面和父页面通信，用到。



6. http2和http1的区别
http1.0 ------->  http1.1
优化了缓存处理，加了Entity Tag等，主要区别获取文件版本，类似最后修改时间，判断文件是否被修改。
长链接，默认开启connection:keep-alive,弥补http1.0每次请求都要创建链接的问题

http1--------> http2
http2支持2进制传送，支持多路复用，支持服务端推送，采用HPACK压缩算法，缩小请求头部，减小传输数据体积



7. 关于缓存
强缓存和协商缓存：强缓存不需要过服务器，协商缓存过服务器；协商缓存状态码是304，两类缓存机制可以同时存在。强缓存优先级更高，如果命中强缓存直接数据库拿不用进行协商缓存。

强缓存：
Expires是服务器返回的缓存到期时间，如果还没到期，直接获取缓存数据，但客户端和服务端时间可能误差，导致缓存命中的误差，目前使用cache-control;
服务器用pragma：no-cache,无缓存，类f5
关于cache-control:
private:客户端可缓存；
public:客户端代理服务器都可缓存；
max-age=t:缓存内容t秒后结束；（比起expires，会优先处理max-age）
no-cache:需要协商缓存验证数据；(不代表不缓存)
no-store:所有内容不缓存。

协商缓存：
协商缓存需要对比判断是否可以使用缓存，第一次请求，服务器会将响应内容加标志返回给客户端，客户端将它备份缓存中，再次请求会将标志发送给服务器，服务器根据标志进行判断，若未失效，
直接使用缓存  ，返回304状态码，浏览器拿到该状态码可以直接使用缓存。

last-modifyed：服务器通知最后修改时间；
if-modify-since:客户端再次请求此字段携带最后修改时间，服务端收到并对比，如果相同，直接304用缓存响应内容。
                已经修改：响应一个整体，200 ok;没有修改：只响应请求头，304 not modifyed
if-Unmodified-since:某个时间点开始算，相对时间，不关心服务端客户端时间误差
http1.1
Etag:服务器告诉客户端响应内容唯一标志，
if-match:客户端请求带上tag,给服务器判断，服务器可根据Etag判断文件是否被修改

大部分场景可使用强缓存和协商缓存共同解决。但也有特殊场景：
不需要缓存使用：Cache-Control:no-store;
频繁变动使用：Cache-Control:no-cache;(协商)
代码文件：Catch-Control:max-age;





8. 首屏加载优化方案
成原因：
DNS解析---Ip去http请求---服务器返回html---解析html触发请求加载js和css---解析css以及执行js(创建DOM，或者virtualDOM)--第一个元素可查看，白屏结束，每一步都可能延迟使得白屏时间过长

解决方式：
1，loading提示，利用webpack的html-webpack-plugin插件，插入loading图。
2，(伪)服务端渲染，服务器返回的html就是带了完整DOM结构的，服务端渲染还对seo友好。nuxt/next
3，开启http2,http2效率更高，http2可以进行多路复用，跟同一域名通信只建立一个TCP,http1需要每个请求建立一个TCP还有并发限制，另外http2可以请求头部压缩，减少请求流量。http2在网络好的时候差异不大，但是差网络优化效果明显。
4，开启浏览器缓存，
5,配置骨架图等等（首次有意义配置FMP）
6,polyfill动态加载，<script src="https://cdn.polyfill.io/v2/polyfill.min.js"></script>，服务商通过识别不同浏览器的userAgent;
7,路由级别拆解代码。先给 babel 设置plugin-syntax-dynamic-import这个动态import 的插件,然后就可以就函数体内使用 import 了.对于Vue 你可以这样引入路由。
8，组件加载：懒加载lazy+Suspense
9,kepp-alive:组件页面跳转依然不销毁组件还能缓存组件中的实例数据。但是需要deactived进行多余的销毁
10，link标签的ref属性使用prefetch，降低下载权重，prefetch加速下一次导航。preload提高下载权重。



9. 谈谈作用域链
作用域：一个独立执行环境，变量不外泄，不会暴露出去，作用就是隔离变量，不同作用域同名变量不会冲突；
作用域链： 一个作用域的自由变量，如果该作用域没有，就会去父作用域(函数定义时的作用域而不是函数执行时)查找该变量，还没有找到则继续往上一个作用域查找，指定找到该变量，或者到Object,这样形成作用域链。



10. 谈谈继承
class: 本质还是函数，class Person {};  person instanceof Function    ====true
继承：子类可调用父类的方法，获取父类属性。es6继承extends+super   es5需要利用原型链获取继承父类方法+apply()或者call()去继承父类属性


11. 谈谈闭包
概念：函数+声明该函数的词法环境组成；私有变量得到私有上下文保护；可能形成不被释放上下文
作用：可使变量长期保存到变量中，声明周期长。但不能滥用，内存泄漏。
     隐藏变量，不被回收，（私有变量，特权变量，存储变量）


12. 谈谈原型链
原型：在JavaScript中原型是一个prototype对象，prototype属性是原型对象用来创建新对象实例，表示类型之间的关系。
原型链：js中对象与对象存在关系，其中的继承关系，是通过prototype属性指向要继承的对象（父对象）实现的，父对象又继承于他的父对 象，直到指向Object对象。这样形成的原型链

当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的 __proto__（即它的构造函数的prototype）中寻找。如果一直找到最上层都没有找到，那么就宣告失败，返回undefined。

每个对象都有__proto__属性，此属性指向该对象的构造函数的原型。



13. vue响应式原理
数据响应式：
object.defineProperty实现数据劫持，对象属性发生改变，会进行其他get+set操作，。多个属性需要数据劫持则需要遍历操作。
es6新增了proxy,vue3利用该对象，进行数据对象变化监听，get(target,key)+set(target key, newValue);
双向绑定：
数据驱动：只关注数据本身。
发布订阅模式：publish+subscribe+eventHub事件中心

基于es5中的保护对象的Object.defineProperty的访问器属性的get和set,data中的数据添加了访问器属性。
任何一个vue component都对应一个watcher实例，vue属性会被添加getter和setter属性。
调用data属性会触发getter,修改data会触发setter.仅需关注数据本身，不需要关心数据如何渲染到视图.
wacher会自动触发重新render,生成新的虚拟DOM,Vue框架利用diff算法对比新旧虚拟DOM,记录修改的地方，局部修改到真实DOM上。




二面：
1.  谈谈事件循环
宏任务：script,定时2，I/O,UIrender
微任务：process，promise,observe,MutationObsever

console.log(1)
async function asyncFunc(){
  console.log(2)
  // await xx ==> promise.resolve(()=>{console.log(3)}).then()
  // console.log(3) 放到promise.resolve或立即执行
  await console.log(3) 
  // 相当于把console.log(4)放到了then promise.resolve(()=>{console.log(3)}).then(()=>{
  //   console.log(4)
  // })
  // 微任务谁先注册谁先执行
  console.log(4)
}
setTimeout(()=>{console.log(5)})
const promise = new Promise((resolve,reject)=>{
  console.log(6)
  resolve(7)
})
promise.then(d=>{console.log(d)})
asyncFunc()
console.log(8)

//=========1,6,2,3,8,7,4,5
==js单线程执行，将不同执行函数，压入执行栈来保证代码有序执行；
==执行1同步任务-->执行完后，将"异步任务对应回调"加入到当前执行栈中不同的另一个任务队列中等待执行。
==任务队列分宏任务，微任务，先微任务，再宏任务。process.nextTick指定的异步任务总是发生在所有异步任务之前
微任务process.nextTick > promise > observe >MutationObsever
宏任务：script>setTime相关>I/O

浏览器中event loop:
js非阻塞单线程语言，避免多个线程同时处理一个DOM节点。
js执行过程会有执行环境，执行栈依次执行，遇到异步代码，放入task，不同异步代码任务分不同任务队列，宏微。

node中 event loop:
有所不同，按6个阶段反复执行，timers-->I/O-->idle,prep,-->poll-->check-->close callback
setTimeout(()=>{
    console.log('timer1')

    Promise.resolve().then(function() {
        console.log('promise1')
    })
}, 0)

setTimeout(()=>{
    console.log('timer2')

    Promise.resolve().then(function() {
        console.log('promise2')
    })
}, 0)

// 以上代码在浏览器和 node 中打印情况是不同的
// 浏览器中一定打印 timer1, promise1, timer2, promise2
// node 中可能打印 timer1, timer2, promise1, promise2
// 也可能打印 timer1, promise1, timer2, promise2




15. 如何避免重排和重绘
重绘：改变外观不影响布局的改动，color的改变等。
回流/重排：布局或者几何属性发生改变。
回流发生必然发生重绘，重绘不一定发生回流，回流成本更高，改变深层次节点可能导致一系列父节点发生回流。

css优化：
    translate代替top，visibility 代替display:none；
    不要把dom节点属性值放操作放循环里
    避免设置多层内联样式，CSS 选择符从右往左匹配查找
    频繁运行的动画单独加图层（video标签单独加了图层）（position:absolute,fixed）
    不要过多使用table，连带效应。
    避免使用CSS表达式，可能回流

js优化
    避免重复操作样式，（最好一次性重写style，或者将样式列表定义到class并一次性更改class属性）
    避免频繁操作DOM，（创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中）
    避免频繁读取会引起重绘和重排的属性，（使用变量缓存，减少读取次数）




16. 关于执行上下文
js执行和解析的环境，创建，执行，回收；
执行栈：一个存储函数调用的栈结构，遵循先进后出的原则



17. 宏任务微任务划分
微任务
process.nextTick
promise
Object.observe
MutationObserver


宏任务
script
setTimeout
setInterval
setImmediate
I/O
UI rendering




18. 如何判断变量类型
typeof---->基础数据类型（null000000--object,000开头，function开头不是000）
Object.prototype.toString.call('');
instanceof 判断A是否为B的实例，instanceof检测的是原型。



19. 说一下vdom和diff
---虚拟DOM是局部更新的一个环节，对视图抽象，为跨平台助力。
---虚拟DOM是JS对象，是对真实DOM的描述
---本质上虚拟DOM是js和DOM之间的映射缓存
操作DOM能耗降低，js运算能耗加大。

关键作用：
    研发体验，研发效率问题；基于函数式UI的编程方式，实现声明式编程。
    跨平台问题；虚拟DOM式对真实渲染内容的一层抽象，一套虚拟DOM对应多套不同平台的渲染逻辑；一次编码，多端运行。
    patch批量更新，新旧虚拟DOM通过diff算法对比，生成补丁集（需要更新的内容）过渡，只看到最后一次更新效果，减少重新渲染流程，减少不必要的高耗能操作。


新老虚拟DOM对比 diff
---首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换
---如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
---比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。 匹配时，找到相同的子节点，递归比较子节点

递归循环，on3复杂度，三大策略降低复杂度：
tree diff:Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。
component diff:相同类的两个组件，生成相似的树形结构，不同类组件，不同树形结构。
element diff:同一层级组件用唯一id区分，如果没有id进行区分，插入操作，导致插入后的列表全部重新渲染。



20. hooks 相对于之前的开发方式有什么特点
代码逻辑聚合，逻辑复用，代替class,HOC嵌套地狱
hooks：
1,轻量，无嵌套地狱，不影响原来的组件结构，
2，对函数组件功能进行增强，让函数组件可以存储状态，可以拥有处理副作用的能力，让开发者在不使用类组件的情况下，实现相同的功能。
3，类组件不足：
            缺少逻辑复用机制；为了复用逻辑增加无实际渲染效果的组件；
            类组件经常会变得很复杂难以维护；将一组相干业务因为太多层级组件，被拆分到多个声明周期函数中，也可能一个生命周期函数内存多个不相关的业务逻辑
            类成员方法不能保证this的正确性
4，由于 Hooks 的特性，状态逻辑会变成更小的粒度，并且极容易被抽象成一个自定义 Hooks，组件中的状态和 UI 变得更为清晰和隔离。
useState(),useEffects()==》拥有处理副作用的能力，类似类组件的声明周期函数。
useReducer(),useContext(),


21. react 开发中有哪些性能优化的方式
类组件：
纯组件作为基类：pureComponent 
shouldComponentUpdate生命周期函数，定义渲染逻辑，避免无用的重复渲染

方法组件：
react.memo高阶函数包装组件，可实现类似shouldComponentUpdate,pureComponent的效果，缓存计算结果，监测值不变则一直不渲染
使用React.useMemo精细化的管控，useMemo 控制的则是是否需要重复执行某一段逻辑，而React.memo 控制是否需要重渲染一个组件。

其他：
在列表需要频繁变动时，使用唯一 id 作为 key，而不是数组下标。
必要时通过改变 CSS 样式隐藏显示组件，而不是通过条件判断显示隐藏组件。
使用 Suspense 和 lazy 进行懒加载


22.  http1到http2优化点
http1.0 ------->  http1.1
优化了缓存处理，加了Entity Tag等，主要区别获取文件版本，类似最后修改时间，判断文件是否被修改。
长链接，默认开启connection:keep-alive,弥补http1.0每次请求都要创建链接的问题

http1--------> http2
http2支持2进制传送，支持多路复用，支持服务端推送，采用HPACK压缩算法，缩小请求头部，减小传输数据体积


23. setState()是异步吗？，如何实现批量更新的策略
合成事件，生命周期函数--》表现为异步；因为在setState的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入dirtyComponents队列中等待执行；否则，开始执行batchedUpdates队列更新；
        在合成事件中，React 是基于 事务流完成的事件委托机制 实现，也是处于事务流中；
        在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而componentDidUpdate是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；
        无法在setState后马上从this.state上获取更新后的值,第二个参数回调函数获取更新后的state值。

原生事件是同步；原生事件是浏览器本身的实现，与事务流无关，自然是同步；而setTimeout是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；

由于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在fn中返回新的state对象即可，例如this.setState((state, props) => newState)；

组件销毁调用setState会报错，1将数据挂载到外部，redux,或者父级中。2做个标记isUnMounted，componentWillUnmount中设置为true.setState前进行判断。

总结：
----setState 只有在 React 自身的合成事件和钩子函数中是异步的，在原生事件和 setTimeout 

----setState 的异步并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的异步。当然可以通过 setState 的第二个参数中的 callback 拿到更新后的结果

----setState 的批量更新优化也是建立在异步（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在异步中如果对同一个值进行多次 setState，setState 的批量更新策略会对其进行覆盖，去最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新
