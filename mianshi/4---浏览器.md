1. 浏览器组成部分，浏览器内核，js引擎，渲染引擎相关
用户界面，浏览器引擎，呈现引擎，网络，js解析器，数据存储，用户界面后端

浏览器内核：渲染引擎(html，css解析并渲染网页)和js引擎(js解析，编译，执行)


2. 浏览器渲染UI流程，渲染机制说明
    获取html文件解析并形成DOM树
    获取css文件并解析形成CSS rules树
    DOM树和style rule树形成render树
    布局阶段，每个节点匹配屏幕具体坐标
    GPU绘制阶段，遍历render树节点，并将元素呈现

    浏览器解析CSS 从右到左：  .mod-nav h3 span {font-size: 16px;}
    解析HTML: 转码二进制，生成tokens,构建带属性的nodes,生成DOM树




3. 重绘重排性能相关
重绘：改变外观不影响布局的改动，color的改变等。
回流/重排：布局或者几何属性发生改变。
回流发生必然发生重绘，重绘不一定发生回流，回流成本更高，改变深层次节点可能导致一系列父节点发生回流。

css优化：
    translate代替top，visibility 代替display:none；
    不要把dom节点属性值放操作放循环里
    避免设置多层内联样式，CSS 选择符从右往左匹配查找
    频繁运行的动画单独加图层（video标签单独加了图层）（position:absolute,fixed）
    不要过多使用table，连带效应。
    避免使用CSS表达式，可能回流

js优化
    避免重复操作样式，（最好一次性重写style，或者将样式列表定义到class并一次性更改class属性）
    避免频繁操作DOM，（创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中）
    避免频繁读取会引起重绘和重排的属性，（使用变量缓存，减少读取次数）




4. 前端实现实时通讯  （消息通知列表，后端消息列表改变，前端及时更改）
短轮询（实现简单，兼容性高，性能消耗高，延迟高） (需要服务器有很快的处理速度和资源，1分钟自动查询一次后端)

websocket（性能好，低延迟，独立的http协议，借助别的成熟库，复杂，兼容性不好）:  基于tcp协议，一个全新的全双工模式（http单工，只能client请求sever,反过来不行），独立的协议。作用就是在客户端和服务端建立实时的双向通信，sever可以发消息给client。
通过sockjs（处理兼容）建立一个跨浏览器的websocket，采用stomp（处理传输协议）消息协议，来订阅、接受服务器的消息。

SSE（传输效率低，相对于websoket简单，不是严格双通信）：基于HTTP，使用简单，改动小。运行服务端向客户端推送新数据的html5技术。





5. 关于浏览器同源策略, 实现跨域相关方式
同源策略：限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互（隔离潜在重要文件安全机制）

同源指的是：协议+域名+端口都相同

<img sre=""/><script src=""></script><link href=XXX><ifram>  不受同源策略限制

跨域解决办法：
 jsonP: 利用script获取资源不受限制，实现跨域(只能get,有安全问题容易xss攻击，需要服务端与jsonp一起进行改造)

cors: 最流行的方案,它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。生产环境中建议用成熟的开源中间件解决问题。

nginx：最方便的解决方式，
    一款高性能的web服务器，高性能，启动块，轻量级
    nginx配置跨域，代理地址需要允许跨域
    sever模块配置，定义一个虚拟访问主机，



1. http协议相关
网络请求方法： 
get,(url传输数据，参数不安全，只能是Ascii字符，刷新后退无害，幂等对服务器资源方面安全)
post,(数据请求体，安全可以，数据类型不限制，刷新后退可能重复提交，非幂等)
put(是幂等的,调用多次和一次一个作用),
delete,
options(获取目的资源支持的通信方式),
head(下载大文件时，判断文件大小，是否需要下载),
connect(将连接改为管道方式的代理服务器),
trace(回显服务器收到的请求，主要用于测试或诊断)


2. http请求，响应相关
请求报文：  
    请求行：方法字段，url字段，协议版本字段；
    请求行头部：键值对user-agent：浏览器类型；accept:客户端可识别内容类型列表；host请求主机名，Cache-Control：控制缓存，Connection 连接管理、逐条首部，Range 实体的字节范围请求，允许多个域名同处一个ip地址(虚拟机)；
    请求体：请求携带数据。

响应报文：
    响应行： 由协议版本，状态码和状态码的原因短语组成
    响应头：响应部首组成；Location 令客户端重定向的URI,ETag 能够表示资源唯一资源的字符串,Allow 资源可支持http请求的方法,Last-Modified 资源最后的修改资源,Expires 实体主体的过期资源;
    响应体：服务器响应的数据

状态码相关：
    200 OK，表示从客户端发来的请求在服务器端被正确处理；
    206 Partial Content，进行范围请求；
    302 found，临时性重定向，表示资源临时被分配了新的 URL；
    304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
    400 bad request，请求报文存在语法错误 
    401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 
    403 forbidden，表示对请求资源的访问被服务器拒绝 
    404 not found，表示在服务器上没有找到请求的资源 
    500 internal sever error，表示服务器端在执行请求时发生了错误 

重定向307，303，302的区别：302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码又出来了两个303和307。303明确表示客户端应当采用get方法获取资源，他会把POST请求变为GET请求进行重定向。 307会遵照浏览器标准，不会从post变为get。

connection:keep-alive  保持长链接http1.1
    减少cpu和内存使用(同时打开链接减少)
    减少后续请求延迟，（无需再进行握手）
    报告错误无需关闭tcp链接
    降低拥塞控制（tcp链接减少）

https如何保证安全的：
    对称加密：通信双方用同一个秘钥加密，(无法首次把秘钥发给对方的问题)
    非对称加密：秘钥+公钥 = 秘钥对


3. http缓存相关
http缓存过程：
    C向S发出请求，请求资源，S返回资源，并通过响应头决定缓存策略；
    根据响应头缓存策略字段信息决定是否缓存，缓存响应头和响应数据；
    C再次请求命中资源时，客户端去查上次缓存的缓存策略，根据策略不同，是否过期等判断是直接读取本地缓存还是与服务器协商缓存。


强缓存和协商缓存：
    强缓存：expires(缓存过期时间，依赖于本地时间，准确性低)和cache-control(失效相对时间，http1.1)(no-store无缓存；no-cache:先缓存本地，但需要与服务器验证新鲜度；public：对所有用户可缓存，终端和CDN等中间代理服务器；private：只能终端浏览器缓存),缓存过期，与服务器进行协商。

    协商缓存：无expires和cache-control(no-cache),进行协商缓存
        缓存和服务器最新资源一支，304,客户端直接用缓存即可，
    判断是否新鲜：last-modified/if-Modified-since（判断是否最新资源）, ETag/if-none-match(资源变化，摘要变化)



4. 关于进程与线程
各自区别和优劣：
进程：资源分配最小单位；线程： 程序执行最小单位。

进程：独立地址空间，系统会分配地址，建立数据表维护代码段，堆栈段和数据段。线程是共享线程中数据，用相同地址空间，CPU切换一个线程的花费远比进程要小很多。

线程之间通信方便，同一进程下的线程共享全局变量，静态变量等，进程通信IPC进行；但是处理好同步和互斥是编写多线程的难点。

多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了。进程死掉不影响其他进程，因为独立地址空间。



5. 关于TCP,三次握手
建立tcp链接  客户端和服务端需要发三次包
第一次握手(SYN=1,seq=x)：客户端发送SYN标志位置1的包，客户端打算链接服务端的端口，以及序列号X,保存在seq;  C  SYN_SEND 状态。

第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)：确认客户端标志位，发送序列号，SYN_RCVD状态

第三次握手(ACK=1，ACKnum=y+1)：客户端再次发送确认包ACK,SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1



客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。


TCP链接的拆除，四次握手链接：
socket 编程中，任何一方执行 close()，可产生挥手操作
客户端想关闭链接，发送标志位置1；
服务端确认，发送确认包，结束关闭请求，但还需要准备；
服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。
客户端接收到来自服务器端的关闭请求，发送一个确认包，等待可能出现的要求重传的 ACK 包。服务端接收到这个确认包，关闭链接。客户端等了一定时间，没收到服务端ACK,认为服务端正常关闭，自己也关闭链接；








