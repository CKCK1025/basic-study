1. 解释下变量提升
js引擎工作方式：先解析代码，获取被声明变量，然后执行代码，
预解释（创建执行环境）（var先声明后赋值）
执行环境：
    作用域链：变量对象+所有父级上下文的变量对象
    变量对象：函数参数/内部变量/函数声明 （根据函数参数初始化，扫描函数内部代码，查找函数声明将函数名函数引用存入变量对象，查找变量声明将变量名存入变量对象并初始化undefined，重复则覆盖）
    this指向
执行阶段：
    变量的值，函数的引用，执行代码

    同变量名，函数声明覆盖变量声明。


2. js运行机制
js引擎：chrome,node常用v8，v8完成编译，内存分配，垃圾回收；

js运行时：v8无法执行ajax请求，设置定时器，响应事件等，需要js运行时，（提供的一些对象和机制）便于与外界交互。

可执行代码：堆（内存分配地址的地方）+调用栈（代码执行的地方）

执行上下文：执行上下文，全局/函数/eval执行上下文；this指向+词法环境+变量环境；
    词法环境：环境记录器（声明式，对象式）+外部环境的引用
    变量环境：只用存储var变量绑定



3. 关于作用域链
作用域链的形成：可执行上下文中的词法环境包含外部环境的引用，可通过这个引用获取外部词法环境的变量、声明，父级词法环境又存有祖及的环境变量、声明；这些引用串联起来，直到指向全局的词法环境，形成作用域链。



4. 关于原型链
原型对象：propertype属性，原型对象创建实例，创建的新对象，都会共享原型对象，可访问原型对象的属性。
原型链： 每个对象都有__proto__，对象的构造函数的原型。__proto__对象链接起来形成原型链。                                                                                                                                                                                                       

5. 关于闭包
闭包的形成：内部函数通过词法环境中的外部环境引用，可以访问到外部函数的变量和声明，即使外部函数被返回；
    函数和声明该函数的词法环境组合。

作用： 长期保存变量，变量私有化，可能内存泄漏



6. ES6模块和commonJS模块
    commonjs 对模块的浅拷贝（基础数据类型，引用的那个模块可对输出模块重新赋值，引用类型，引用对象中属性方法发山变化，则会影响另外一个模块）       
    ES6 module是对模块的引用，只存只读。指针指向不变，（可以给对象添加属性和方法）

    CommonJS模块是运行时加载，ES6 Modules是编译时输出接口

    require()是同步加载模块 ,加载的模块是一个对象（module.exports属性）  
    import命令是异步加载，ES6模块不是对象，对外接口只是一种静态定义，在代码静态解析阶段就会生成。

    require一个模块值，不会再执行该模块，而是取缓存中的值，无论commonjs加载多少次，都只会在第一次加载运行一次。
    import一个模块，对于动态来说，原始值发生变化，import加载的值也会发生变化。不论是基本数据类型还是复杂数据类型。

commonjs  加载不提升require()，this指向当前模块。
es6  编译期间加载提升import，this指向undefined


7. 关于this
this绑定：创建可执行上下文的时候根据代码执行条件，来判断分别进行默认，隐式，显式绑定。
思路：1，判断函数类型:
    箭头函数: 是包裹箭头函数第一个执行环境中的this;
    aplly,bind,call: this是函数中的第一个参数;
    普通函数则看调用方式：
        new的方式: this固化在实例上。
        非new的方式：foo(),this是window,obj.foo()，this则是obj;



8. async/await和promise
async是genneratot语法糖，
async: 
将常规函数转为promise，返回值也是promise
只有async函数内部异步函数执行完，才会执行then中指定的回调函数
异步函数内部可以使用await

await:
放置在promise调用之前，强制别的代码等待，知道promise执行完并返回结果。
只适合与promise一起使用，不适合用于回调
只能再async函数内部使用

async/await相比于promise的优势：
    代码阅读性更好，同步化，promise链式调用太长
    promise传递中间值麻烦，async/await几乎同步写法
    错误处理有好，async/await可以使用try/catch.
    调试有好，调试器只跟同步代码，不能再返回表达式的箭头函数中设置断点。





