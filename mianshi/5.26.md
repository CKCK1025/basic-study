1. js异步编程
异步模式：同时执行多个任务，不阻塞。由于js是单线程。利用多核能力，web worker允许js创建多个线程，但子线程受控于主线程，且不操作DOM.

异步场景： 网络请求，定时任务，动态加载，事件绑定

关于promise:未来发生事件，将异步以同步的流程表达出来，避免回调地狱。
            Promise是构造函数，三个状态：pengdding,fullfilled, reject
    特点：then方法产生全新的promise对象，（类似回调函数）

generator: 状态机，存有多个状态，执行generator函数会返回一个遍历器对象（next()）(yield 暂停代码)
    generator: 执行器

async: 
将常规函数转为promise，返回值也是promise
只有async函数内部异步函数执行完，才会执行then中指定的回调函数
异步函数内部可以使用await

await:
放置在promise调用之前，强制别的代码等待，知道promise执行完并返回结果。
只适合与promise一起使用，不适合用于回调
只能再async函数内部使用

async/await相比于promise的优势：
    代码阅读性更好，同步化，promise链式调用太长
    promise传递中间值麻烦，async/await几乎同步写法
    错误处理有好，async/await可以使用try/catch.
    调试友好，调试器只跟同步代码，不能再返回表达式的箭头函数中设置断点。


2. 事件循环
单线程任务分同步任务和异步任务，同步任务再调用栈依次执行，异步任务等待调用栈空了闲暇时执行。
执行栈执行同步任务，执行完删除任务=====执行栈为空时先检测微任务并执行，每个宏任务执行完检测是否有微任务需要执行======微任务执行完就执行宏任务（异步），异步代码中又有微任务，异步宏任务，同理执行。

====================================
console.log('script start')
async function async1() {
  await async2()
  console.log('async1 end')
}
async function async2() {
  console.log('async2 end') 
}
async1()
setTimeout(function() {
  console.log('setTimeout')
}, 0)
new Promise(resolve => {
  console.log('Promise')
  resolve()
})
  .then(function() {
    console.log('promise1')
  })
  .then(function() {
    console.log('promise2')
  })
console.log('script end')

==========================================
console.log('start')
setTimeout(() => {
  console.log('timer1')
  Promise.resolve().then(function() {
    console.log('promise1')
  })
}, 0)
setTimeout(() => {
  console.log('timer2')
  Promise.resolve().then(function() {
    console.log('promise2')
  })
}, 0)
Promise.resolve().then(function() {
  console.log('promise3')
})
console.log('end')

====================================
console.log('a');

setTimeout(() => {
    console.log('timeout 1')
}, 1000)

setTimeout(() => {
    console.log('timeout 2')
    Promise.resolve().then(() => console.log('timeout 2 promise'))
}, 0)

console.log('b')

new Promise((resolve, reject) => {
    console.log('promise 1')
    resolve()
    console.log('promise 2')
})
.then(() => {
    console.log('promise 3')
    setTimeout(() => console.log('promise 3 timeout'), 500)
})
.then(() => {
    console.log('promise 5')
})

console.log('c')



3. js内存管理，垃圾回收
一个基本类型被闭包引用后，这时的基本类型也存在堆中
分配内存，使用(读写)内存，不需要时释放

垃圾： 不再被引用的对象以及不能从根本上访问到的对象

常见GC算法：
=====
    引用计数算法：记录引用次数，引用+1，引用完结-1，最终判断次数为0则为垃圾需要回收
    优缺点：垃圾立即回收，减少停顿卡顿，但是不能回收循环引用的对象，时间资源开销大。

=====
    标记清除算法：遍历标记活动对象，遍历对象清除没标记的
    优缺点：可清除循环引用对象，但产生碎片化空间，浪费空间

=====
    标记整理算法：遍历标记活动对象，先整理移动对象在清除
    优缺点：减少空间，但不会立即回收垃圾对象


v8回收：
  回收策略：分代回收思想，内存分为新生代和老生态(内存一分为二，新生代对象内存小)。新生代用GC算法，老生代用老算法，不易回收。


performance工具：
  监控内存的几种方式：
    浏览器任务管理器shift+esc
    timeline时序图记录
    堆快照查找分离DOM
    判断是否频繁垃圾回收：timeline中频繁的上升下降，


关于内存相关代码优化：
  慎用全局变量，缓存全局变量(比如缓存document)
  定时器销毁，DOM引用不规范
  通过原型对象添加属性方法prototype
  避开闭包陷阱
  文档碎片化节点添加：定义变量拿到多个节点，一次性转入某个节点，回流和重绘减少
  直接量 替换 new Object；克隆相同节点 替换  创建相同节点,







