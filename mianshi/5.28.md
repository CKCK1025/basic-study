1. 浏览器组成部分，浏览器内核，js引擎，渲染引擎相关
用户界面，浏览器引擎，呈现引擎，网络，js解析器，数据存储，用户界面后端

浏览器内核：渲染引擎(html，css解析并渲染网页)和js引擎(js解析，编译，执行)


2. 浏览器渲染UI流程，渲染机制说明
    获取html文件解析并形成DOM树
    获取css文件并解析形成CSS rules树
    DOM树和style rule树形成render树
    布局阶段，每个节点匹配屏幕具体坐标
    GPU绘制阶段，遍历render树节点，并将元素呈现

    浏览器解析CSS 从右到左：  .mod-nav h3 span {font-size: 16px;}
    解析HTML: 转码二进制，生成tokens,构建带属性的nodes,生成DOM树


3. 重绘重排性能相关
重绘：改变外观不影响布局的改动，color的改变等。
回流/重排：布局或者几何属性发生改变。
回流发生必然发生重绘，重绘不一定发生回流，回流成本更高，改变深层次节点可能导致一系列父节点发生回流。

css优化：
    translate代替top，visibility 代替display:none；
    不要把dom节点属性值放操作放循环里
    避免设置多层内联样式，CSS 选择符从右往左匹配查找
    频繁运行的动画单独加图层（video标签单独加了图层）（position:absolute,fixed）
    不要过多使用table，连带效应。
    避免使用CSS表达式，可能回流

js优化
    避免重复操作样式，（最好一次性重写style，或者将样式列表定义到class并一次性更改class属性）
    避免频繁操作DOM，（创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中）
    避免频繁读取会引起重绘和重排的属性，（使用变量缓存，减少读取次数）

4. 前端实现实时通讯  （消息通知列表，后端消息列表改变，前端及时更改）
短轮询（实现简单，兼容性高，性能消耗高，延迟高） (需要服务器有很快的处理速度和资源，1分钟自动查询一次后端)

websocket（性能好，低延迟，独立的http协议，借助别的成熟库，复杂，兼容性不好）:  基于tcp协议，一个全新的全双工模式（http单工，只能client请求sever,反过来不行），独立的协议。作用就是在客户端和服务端建立实时的双向通信，sever可以发消息给client。
通过sockjs（处理兼容）建立一个跨浏览器的websocket，采用stomp（处理传输协议）消息协议，来订阅、接受服务器的消息。

SSE（传输效率低，相对于websoket简单，不是严格双通信）：基于HTTP，使用简单，改动小。运行服务端xiang向客户端推送新数据的html5技术。


5. 关于浏览器同源策略, 实现跨域相关方式
同源策略：限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互（隔离潜在重要文件安全机制）

同源指的是：协议+域名+端口都相同

<img sre=""/><script src=""></script><link href=XXX><ifram>  不受同源策略限制

跨域解决办法：
 jsonP: 利用script获取资源不受限制，实现跨域(只能get,有安全问题容易xss攻击，需要服务端与jsonp一起进行改造)

cors: 最流行的方案,它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。生产环境中建议用成熟的开源中间件解决问题。

nginx：最方便的解决方式，
    一款高性能的web服务器，高性能，启动块，轻量级
    nginx配置跨域，代理地址需要允许跨域
    sever模块配置，定义一个虚拟访问主机，












