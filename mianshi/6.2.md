1. 对MVVM的理解
Model:对应数据层的域模型，通过ajax/fetch完成客户端和服务端业务同步。
View层不处理状态，只是做数据绑定的声明，指令的声明，事件的声明。
ViewModel层对view的声明负责，也就是处理view层的具体业务逻辑，做好绑定属性的监听。

优点：
1，分离视图和模型，一个viewModel可以被多个view使用，多个view服用viewModel视图逻辑，降低耦合性。
2，提高测试性，更好的编写测试代码。
3,自动更新dom,利用双向绑定，数据更新然后视图自动哥更新。

缺点：
1，对于大型的图形应用，视图较多，维护成本高。
2，bug更难定位，


2. vue生命周期
开始创建new vue();
data,method等初始化前后： beforeCreat/created;     异步放在created
加载dom前后   beforeMount/mounted;   
更新前后      beforeUpdated/Updateed;  
销毁前后     beforeDestory/Desboed
beforeDestory(): 做收尾工作, 如: 清除定时器


3. computed和watch的理解和区别
computed: 计算属性，计算场景，有缓存性，getter执行后会缓存，也可加set。直到依赖的属性发生改变，

watch:观察作用，数据的监听，用于观察props,$emit当监听数据发生变化时，执行回调进行数据的逻辑操作；无缓存性，页面重新渲染时值不变。

需要依赖别的属性来动态获取值的时候用watch;对于监听到值得变化需要做逻辑处理用watch;


4. vue如何实现双向绑定
Object.defineProperty劫持对象的访问器,在属性值发生变化时我们可以获取变化，通过proxy代理对象进行类似操作
数据改变，视图会变，视图改变，数据也会改变

Object.defineProperty实现数据劫持，对象属性发生改变时，进行一些其他操作。get() + set() ;多个属性都需要数据劫持，则需要遍历进行操作。一一挂载。(不兼容ie8)(vue2)；

es6新增对象Proxy, vue3利用该对象，进行数据对象变化监听。get(target, key) + set(target,key, newValue);

Proxy与Object.defineProperty的优劣对比?
    可直接监听对象而非属性，可监听数组变化，更多种拦截方法has,deleteProperty等，Proxy返回一个新对象，可以只操作心得对象。Proxy时es6，用于Vue3(兼容性差一点);



5. 如何理解vue响应式系统
    基于es5中的保护对象的Object.defineProperty的访问器属性的get和set,data中的数据添加了访问器属性。
    任何一个vue component都对应一个watcher实例，vue属性会被添加getter和setter属性。
    调用data属性会触发getter,修改data会触发setter.仅需关注数据本身，不需要关心数据如何渲染到视图.
    wacher会自动触发重新render,生成新的虚拟DOM,Vue框架利用diff算法对比新旧虚拟DOM,记录修改的地方，局部修改到真实DOM上。




6. 既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异?
侦测变化，pull和push
pull代表时react,setState+virtualDom Diff算法找差异，然后改变dom.一开始不知道哪里发生变化，暴力Diff查找哪里变化了。

pash代表vue,一开始进行data数据依赖收集，响应及时，一开始就知道哪里发生了变化，绑定一个数据就需要一个watcher,细粒度过高，产生大量的watcher,vue时push+pull结合，选择中等细粒度的方案。


7. Vue为什么没有类似于React中shouldComponentUpdate的生命周期？
也是由于react和vue变化侦不同，react只能diff检查变化，很多时候为了避免没有必要的diff对比，添加了shouldCopnentUpdate方法，vue通常不需要diff,目前没有引入该声明周期方法


8. Vue中的key到底有什么用？,v-for中key最好不要用index原因
有利于diff算法更准确，更快速匹配查找对比，无唯一key遍历查找复杂度On，和有唯一标志遍历查找复杂度为O1


9. 单页应用如何优化SEO(搜索引擎优化)




10. VueX之actions与mutations的区别
预渲染的方式，对网页的路由制定模板
使用服务端渲染SSR


