1. 发布/订阅模式和观察者模式
发布订阅模式：统一调度中心调度，发布者和订阅者不需要知道对方的存在
发布者publish，订阅者subscrib，信号中心。某个任务执行完成向信号中心发布一个信号，其他任务从信号订阅这个信号，
从而知道什么时候执行。
$emit('',()=>{})发布；$on('',()=>{})

观察者模式：由目标者调度，发布和订阅存在依赖。
观察者watcher,update(),当事件发生时，具体要做的事情。
目标dep:
subs：存储所有观察者；addSub：添加观察者；notify:当事件发生，调用所有观察者的update方法。




2. 为什么使用 Virtual DOM
---简化DOM操作，jquery虽然简化了DOM操作，但是复杂项目还是麻烦，还要考虑兼容性问题。于是出现各种MVVM框架，
   MVVM解决了视图和数据同步问题。
---为了简化操作利用了模板引擎handlebar,但是没有解决跟踪状态改变的问题，virtual DOM出现。
---状态改变时，不需要立即更新DOM,只需要创建一个虚拟DOM,通过diff实现正确的局部更新真实DOM。
---虚拟DOM是局部更新的一个环节，对视图抽象，为跨平台助力。
---虚拟DOM是JS对象，是对真实DOM的描述
---本质上虚拟DOM是js和DOM之间的映射缓存


作用：
维护视图和状态的关系；
复杂视图情况下，提高渲染性能；
除了DOM以外，还可以实现SSR（next.js/nuxt.js）,原生应用（weex/react Native），小程序等
一次改变，减少重绘和回流，vnode只需要实现一些必要属性。

关键作用：
    研发体验，研发效率问题；基于函数式UI的编程方式，实现声明式编程。
    跨平台问题；虚拟DOM式对真实渲染内容的一层抽象，一套虚拟DOM对应多套不同平台的渲染逻辑；一次编码，多端运行。
    批量更新，只看到最后一次更新效果，减少重新渲染流程，减少不必要的高耗能操作。




3. vue 和 react技术选型
相同点：
1，数据驱动页面，提供响应式的视图组件
2，都有vDOM，组件化开发，都通过props进行父子组件数据传递，都实现了webComponent规范
3，数据流动单向，都支持SSR
4,都支持native的方法，react 的React native,vue的wexx

不同点
1，vue实现了双向数据绑定，react单向数据流动
2，数据渲染，大规模渲染，react更快
3，场景：react+redux适合多人大项目，vue更倾向于小快项目
4，开发风格，react的jsx,把html和css都写入js了。



4. 关于nextTick
用于下次DOM更新循环结束之后执行延迟回调，用于获得更新后的DOM




5. 关于vuerouter和vuex
vuerouter:
    mode:   hash   history
    跳转：this.$router.push,replace,go    <router-link to=""></router-link>
    占位符： <router-view></router-view>
    源码实现：
        作为一个插件存在，实现vueRouter类和install方法
        实现两个全局组件：router-view用于显示匹配组件内容，router-link用于跳转
        监控url变化：监听hashChange和postate事件
        响应最新url：创建一个响应式属性current，当他改变获取对应组件并显示。

vuex:
    vue component---->action---->Mutaion--->state(getters,module)--->vue Component
    module将state分为多个module便于管理。 
    getters 获取state中被处理后的数据。
    实现：
        store类：
            方法：dispatch(actions),commit(Mutaion);
            属性：state,getters
        install:Mixin混入store实例
            beforeCreate(){
                vue.property.$store = this.options.store;
            }



6. keep-alive实现原理
如果你需要在组件切换的时候，保存组件的状态值，不被销毁，不被多次重新渲染，使用keep-alive包裹需要保存组件；
keep-alive：包含两个生命周期函数，activated和deactivated.组件切换的时候不被销毁而是缓存到内存中，命中缓存时调用activated获取缓存值。    

props 传入参数include包含哪些组件会被缓存,exclude不缓存哪些,max最多缓存组件数
当两个组件都缓存了，互相切换可能错误的时候，需要beforeEach钩子需要更改



7. mixin 和 mixins 区别
mixin 用于全局混入，会影响每个组件实例，通常插件都是这样做初始化的；通常全局混入ajax或者一些工具函数

部分组件之间有相同逻辑部分，用到了mixins混入代码；mixins混入的钩子函数会先于组件的钩子函数执行。


8. vue编译过程
vue通过编译器，通过几个阶段编译为render函数，然后通过执行render生成虚拟DOM,最终映射为真实DOM
    其中的几个阶段包括：
        将模板解析为AST（利用各种正则表达式等）
        优化AST
        将AST转化为render函数



9. vue3新特性，亮点
vue3
    重构响应式系统，利用了es6中的proxy对象，proxy优势:
        可直接监听数组类型的变化，
        监听的目标为对象本身，不需要defineproperty去遍历，性能得到提升
        可拦截apply，ownKeys,has等13种方法，而defineproperty不能
        直接实现对象属性的新增和删除。
    新增了composition API，更好的逻辑服用和代码组织
    重构virtual DOM
        slot优化，slot编译为lazy函数，将slot的渲染决定权交给子组件
        模板中内联事件的提取和重用
    使用typescript替换flow



