1. 谈谈虚拟DOM
---简化DOM操作，jquery虽然简化了DOM操作，但是复杂项目还是麻烦，还要考虑兼容性问题。于是出现各种MVVM框架，
   MVVM解决了视图和数据同步问题。
---为了简化操作利用了模板引擎handlebar,但是没有解决跟踪状态改变的问题，virtual DOM出现。状态改变时，不需要立即更新DOM,只需要创建一个虚拟DOM,通过diff实现正确的局部更新真实DOM。
---虚拟DOM是局部更新的一个环节，对视图抽象，为跨平台助力。
---虚拟DOM是JS对象，是对真实DOM的描述
---本质上虚拟DOM是js和DOM之间的映射缓存


作用：
维护视图和状态的关系；复杂视图情况下，提高渲染性能；
除了DOM以外，还可以实现SSR（next.js/nuxt.js）,原生应用（weex/react Native），小程序等
一次改变，减少重绘和回流，vnode只需要实现一些必要属性。
相对于直接操作DOM,能耗降低，但是js计算的能耗更大。DOM操作能耗更大，故相对好一些

关键作用：
    研发体验，研发效率问题；基于函数式UI的编程方式，实现声明式编程。
    跨平台问题；虚拟DOM式对真实渲染内容的一层抽象，一套虚拟DOM对应多套不同平台的渲染逻辑；一次编码，多端运行。
    patch批量更新，新旧虚拟DOM通过diff算法对比，生成补丁集（需要更新的内容）过渡，只看到最后一次更新效果，减少重新渲染流程，减少不必要的高耗能操作。




2. redux的工作流程? react-redux是如何工作的?
redux:
----view用户操作-->action(dispatch)-->reducer-->store-->view,严格的单向数据流；
    store:保存状态数据的容器
    state:store包含的状态数据，在某个时间点的数据快照，就叫做state;
    action:state的变化会导致view的变化，用户交互是，通过action发出通知，表示state应该要发生变化。（action creator）
    reducer:store收到action,必须给出一个新的state,reducer是一个函数，它接受Action和当前State作为参数，经过逻辑计算，返回一个新的State。
    dispatch: view发出action的唯一方法
----redux是js的状态容器，提供可预测的状态管理
----修改数据，只能派发action,reducer将根据action内容的不同执行不同的计算逻辑，最终生成新的state，新的state更新到store,进而驱动视图做出响应改变。
----核心对象createStore,核心方法dispatch,串联三个核心要素


react-redux
provider:作用是从最外部封装了整个应用，并向connect传递store
connect: 负责连接React和redux
----获取state:通过context获取provider中的store,store.getState获取state
----包装原组件：state和action通过props的方式传入到原组件内部wrapWithConnect返回一个ReactComponent对象Connect。
----监听state变化：connect缓存了state tree中state状态，新旧state比较，判断是否调用了setState()触发connect及其子组件的重新渲染。




3. redux与mobx的区别?
redux一个store,mobx多个store;
修改获取数据不同，mobx用装饰器，mobx数据是可变的，redux可以有只读状态，
mobx相对简单。
redux用作全局状态管理，mobx用作组件装填管理。
redux具有不可变的特性，适合有回溯需求的应用。



4. redux异步中间件之间的优劣?
redux-thunk:实现简单。耦合严重，异步操作和redux的action在一起，不方便管理，功能不完善
redux-saga:异步解耦，异步代码不会掺杂在action，和components;异常处理得益于gennerator,代码异常或失败，可以用try-catch
           提供大量的辅助函数，减少某些功能封装；更加灵活，可以将多个saga组合起来。但是体积大，功能过剩，ts支持不友好，yield无法范围。



5. 关于react router
history和路由原理：
---关于history,一个第三方js库，可以用来兼容不同浏览器和不同环境下对历史记录的管理。主要三种，旧版本浏览器：通过hash实现，createHashHistory；新版本浏览器html5的history：createBrowserHistory；node环境用memory，createMemoryHistory；三种公共的createHistory;
---执行url的前进：pushState、replaceState；location.hash="",location.replace=""
---关于url的检测：createHashHistory：popstate；createBrowserHistory: hashChange；
---关于state:  存储到sesstionStorage;
---原理：监听url变化，路由匹配，响应响应页面；hash+history

react-router:
---基本原理url--->UI =  history--->components
---优点:配合react风格，url配置可用components；不需要手工维护配置，强大的路由配置（组件+配置对象）；可用通过link和redirect(服务端)进行切换；同步加载和异步加载，可用按需加载；


6. dva总结
---