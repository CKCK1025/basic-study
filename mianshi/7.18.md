1. 首屏白屏优化相关
造成原因：
DNS解析---Ip去http请求---服务器返回html---解析html触发请求加载js和css---解析css以及执行js(创建DOM，或者virtualDOM)--第一个元素可查看白屏结束
每一步都可能延迟使得白屏时间过长

解决方式：
1，loading提示，利用webpack的html-webpack-plugin插件，插入loading图。
2，(伪)服务端渲染，服务器返回的html就是带了完整DOM结构的，服务端渲染还对seo友好。nuxt/next
3，开启http2,http2效率更高，http2可以进行多路复用，跟同一域名通信只建立一个TCP,http1需要每个请求建立一个TCP还有并发限制，另外http2可以头部压缩，减少请求流量。http2在网络好的时候差异不大，但是差网络优化效果明显。
4，开启浏览器缓存，
5,配置骨架图等等（首次有意义配置FMP）
6,polyfill动态加载，<script src="https://cdn.polyfill.io/v2/polyfill.min.js"></script>，服务商通过识别不同浏览器的userAgent;
7,路由级别拆解代码。先给 babel 设置plugin-syntax-dynamic-import这个动态import 的插件,然后就可以就函数体内使用 import 了.对于Vue 你可以这样引入路由。
8，组件加载：懒加载lazy+Suspense
9,kepp-alive:组件页面跳转依然不销毁组件还能缓存组件中的实例数据。但是需要deactived进行多余的销毁



2. js执行优化相关
动画性能： css3 + canvas + DOM
css3:  图层+回流+重绘   尽量将动画防单独一个图层，避免回流和重绘，尽量使用GPU
    创建合成层，尽量用transform或者opacity等，opacity+translate+rotate+scale会获得GPU加速
canvas动画： 运用requestAnimationFrame，能将所有动画都放到一个浏览器重绘周期里边去做，懂不不是激活自动关闭
            离屏canvas将重要绘制内容缓存，避免浮点运算，webworker

大量数据性能
几千行几万行需要渲染的列表，需要用到虚拟列表，
webworker:大量数据计算的时候用webworker,一个独立的线程，完成和UI线程并行的执行js,他和主线程通过onMessage和postMessage进行通信。
主线程处理界面事件的时候，webworker后台进行计算处理数据。



3. react 关于hooks




4. 浏览器渲染




5. 缓存相关
相关响应头：
Expires:响应头，资源过期时间；
cache-control:缓存控制字段，精确控制缓存策略。
if-modified-since: 最近修改时间，c告诉s
last-modified:最近修改时间，s告诉c
