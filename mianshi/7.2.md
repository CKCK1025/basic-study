1. react最新的生命周期，
    初始化阶段：
        constructor:构造函数;
        getDerivedStateFromProps(componentWillMount):静态属性，接收到父组件属性变化更改state;
        render:纯函数，返回需要渲染的东西，原生DOM,react组件，Fragment,字符串，布尔值，数字，null值。
        componentDidMount：组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对canvas，svg的操作，服务器请求等。

    更新阶段：
        getDerivedStateFromProps：(初始化更新都可能用到)
        shouldComponentUpdate:是否触发重新渲染
        render：更新渲染
        getSnapshotBeforeUpdate：返回值作为componentDidUpdate第三个参数
        componentDidUpdate:(prevProps, prevState, snapshot)

    卸载阶段：
        componentWillUnmount： 卸载前调用



2. 关于setState
有时异步，有时同步；
====合成事件和钩子函数是异步，原生函数是同步
====并不是内部代码是异步，执行过程和代码是同步的，只是合成事件和钩子函数调佣顺序再更新之前，没办法立马拿到更新后的值，形成所谓的异步，可以通过第二个参数回调函数拿到更新后的值。
====批量更新优化建立在异步之上，对同一个值进行多次更改，setState会覆盖操作取最后一次的值。对多个不同的值操作会合并操作



3. react组件通信相关,
父子通信：props ，props+回调的方式，
兄弟通信：找到共同父节点，再结合父子通信方式。
跨层级通信：
    发布订阅， 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入event模块进行通信。
    借助redux或者mobx，这种工具会维护一个全局管理状态中心store,根据不同的事件产生新状态。(数据层框架，react-redux等)




4. 关于组件逻辑复用
高阶组件：属性代理，反向继承;react组件包裹着另外一个react组件；
    属性代理：HOC对传给WrappedComponent W的props操作;
    反向继承：HOC继承WrappedComponent W
    
渲染属性
react-hooks



5. mixin、hoc、render props、react-hooks的优劣如何？
mixin的缺陷：mixin存在隐性依赖，mixin经常依赖组件的特定方法，但是定义组件时不知道依赖关系
            多个mixin之间可能产生冲突，比如多个相同的state
            隐式依赖依赖关系不透明，维护成本高，难以快速理解组件行为，组件自身的方法和state不好删改，难以确定有没有mixin依赖它。

Hoc的优势：

Hoc的缺陷：
            




6. 你是如何理解fiber的?
一种基于浏览器的单线程调度算法
react16之前，用reconcilation算法，实际是递归，庞大组件对比，主线程无法立即停止释放；react16之后用循环代替递归。
Fiber:一种将reconcilation递归diff拆分为无数个小任务，随时可以停止，恢复。停止恢复的时机，取决于当前一帧内。还有没有足够的时间允许计算。
时间分片，






