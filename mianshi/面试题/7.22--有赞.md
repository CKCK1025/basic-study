1. 选择器，以及选择器优先级
!important--->内联-->id--->类/属性/伪类--->元素/伪元素--->关系选择器/通配符选择器



2. 谈谈bfc
是什么：块级格式上下文，一个独立环境，容器这个块box中的布局与容器外的毫无相关。
触发条件：根元素html;
        float值不为none;
        overflow值不为visible,display值为inline-block,table-cell,table-caption;
        position值为absolute或者fixed
特别作用：可以阻止元素被浮动元素覆盖
        可以包含浮动元素
        同个bfc下两个元素会margin重叠，两个不同bfc下的元素margin不会重叠



3. 盒模型
w3c:
width = contentW,
ie情况： width = contentw+border+padding(box-sizing: border-box)



4. 左固定，右适应布局
float:left + margin
calc
float + overflow(开启bfc)
利用flex实现:width + flex:1 



5. 关于跨域
限制一个源的文档或者它加载的脚本如何与另一个源进行交互，即同源策略限制，协议，ip-域名，端口;
无同源策略，接口请求，DOM查询。

我遇到的JSONP,cors,Nginx，postMessage

JSONP只能get,
实现JSONP: 定义获取跨域响应数据的回调函数，并通过没有同源策略限制的script标签发起请求，然后服务端返回该回调函数的执行，并将数据带入回调函数。
JSONP风险：
csrf攻击：将一个网站隐私cookie携带到另外一个网站，被盗取。cookie机制，后端可以设置httpOnly，前端不可操作cookie；
xss漏洞：获取目标网站DOM，盗用信息。（严格定义content-type:application/json,过滤callback参数，进行字符转义，防止脚本    ）

cors:跨域资源共享
1,浏览器请求头加origin
2,服务端配置，Access-Control-Allow-Methods,Access-Control-Allow-Headers,Access-Control-Allow-Origin;指定可访问的方法，头部，源信息
3，请求分为简单和非简单，非简单会先进行探针option方法进行预检，判断是否允许当前跨域请求。

Access-Control-Allow-Origin：要么请求的origin字段，要么*通配符
Access-Control-Allow-Credentials: 是否允许携带cookie
Access-Control-Expose-Headers: cors请求，XMLHttpRequest对象只能拿catch-control,content-language,content-type,expires,last-modifyed,pragma;其他请求头需要单独配置。

postMessage: 
iframe页面嵌入，ifram页面和父页面通信，用到。



6. http2和http1的区别
http1.0 ------->  http1.1
优化了缓存处理，加了Entity Tag等，主要区别获取文件版本，类似最后修改时间，判断文件是否被修改。
长链接，默认开启connection:keep-alive,弥补http1.0每次请求都要创建链接的问题

http1--------> http2
http2支持2进制传送，支持多路复用，支持服务端推送，采用HPACK压缩算法，缩小请求头部，减小传输数据体积



7. 关于缓存
强缓存和协商缓存：强缓存不需要过服务器，协商缓存过服务器；协商缓存状态码是304，两类缓存机制可以同时存在。强缓存优先级更高，如果命中强缓存直接数据库拿不用进行协商缓存。

强缓存：
Expires是服务器返回的缓存到期时间，如果还没到期，直接获取缓存数据，但客户端和服务端时间可能误差，导致缓存命中的误差，目前使用cache-control;
服务器用pragma：no-cache,无缓存，类f5
关于cache-control:
private:客户端可缓存；
public:客户端代理服务器都可缓存；
max-age=t:缓存内容t秒后结束；（比起expires，会优先处理max-age）
no-cache:需要协商缓存验证数据；(不代表不缓存)
no-store:所有内容不缓存。

协商缓存：
协商缓存需要对比判断是否可以使用缓存，第一次请求，服务器会将响应内容加标志返回给客户端，客户端将它备份缓存中，再次请求会将标志发送给服务器，服务器根据标志进行判断，若未失效，直接使用缓存  ，返回304状态码，浏览器拿到该状态码可以直接使用缓存。

last-modifyed：服务器通知最后修改时间；
if-modify-since:客户端再次请求此字段携带最后修改时间，服务端收到并对比，如果相同，直接304用缓存响应内容。
                已经修改：响应一个整体，200 ok;没有修改：只响应请求头，304 not modifyed
if-Unmodified-since:某个时间点开始算，相对时间，不关心服务端客户端时间误差
http1.1
Etag:服务器告诉客户端响应内容唯一标志，
if-match:客户端请求带上tag,给服务器判断，服务器可根据Etag判断文件是否被修改

大部分场景可使用强缓存和协商缓存共同解决。但也有特殊场景：
不需要缓存使用：Cache-Control:no-store;
频繁变动使用：Cache-Control:no-cache;(协商)
代码文件：Catch-Control:max-age;





8. 首屏加载优化方案
成原因：
DNS解析---Ip去http请求---服务器返回html---解析html触发请求加载js和css---解析css以及执行js(创建DOM，或者virtualDOM)--第一个元素可查看，白屏结束，每一步都可能延迟使得白屏时间过长

解决方式：
1，loading提示，利用webpack的html-webpack-plugin插件，插入loading图。
2，(伪)服务端渲染，服务器返回的html就是带了完整DOM结构的，服务端渲染还对seo友好。nuxt/next
3，开启http2,http2效率更高，http2可以进行多路复用，跟同一域名通信只建立一个TCP,http1需要每个请求建立一个TCP还有并发限制，另外http2可以请求头部压缩，减少请求流量。http2在网络好的时候差异不大，但是差网络优化效果明显。
4，开启浏览器缓存，
5,配置骨架图等等（首次有意义配置FMP）
6,polyfill动态加载，<script src="https://cdn.polyfill.io/v2/polyfill.min.js"></script>，服务商通过识别不同浏览器的userAgent;
7,路由级别拆解代码。先给 babel 设置plugin-syntax-dynamic-import这个动态import 的插件,然后就可以就函数体内使用 import 了.对于Vue 你可以这样引入路由。
8，组件加载：懒加载lazy+Suspense
9,kepp-alive:组件页面跳转依然不销毁组件还能缓存组件中的实例数据。但是需要deactived进行多余的销毁



9. 谈谈作用域链
作用域：一个独立执行环境，变量不外泄，不会暴露出去，作用就是隔离变量，不同作用域同名变量不会冲突；
作用域链： 一个作用域的自由变量，如果该作用域没有，就会去父作用域(函数定义时的作用域而不是函数执行时)查找该变量，还没有继续往上一个作用域查找，指定找到该变量，或者到Object,这样形成作用域链。



10. 谈谈继承



11. 谈谈闭包
概念：函数+声明该函数的词法环境组成；私有变量得到私有上下文保护；可能形成不被释放上下文
作用：可使变量长期保存到变量中，声明周期长。但不能滥用，内存泄漏。



12. 谈谈原型链
原型：在JavaScript中原型是一个prototype对象，prototype属性是原型对象用来创建新对象实例，表示类型之间的关系。
原型链：js中对象与对象存在关系，其中的继承关系，是通过prototype属性指向要继承的对象（父对象）实现的，父对象又继承于他的父对 象，直到指向Object对象。这样形成的原型链

当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的 __proto__（即它的构造函数的prototype）中寻找。如果一直找到最上层都没有找到，那么就宣告失败，返回undefined。

每个对象都有__proto__属性，此属性指向该对象的构造函数的原型。




13. vue响应式原理
14. 谈谈事件循环
宏任务：script,定时2，I/O,UIrender
微任务：process.



15. 如何避免和重绘
重绘：改变外观不影响布局的改动，color的改变等。
回流/重排：布局或者几何属性发生改变。
回流发生必然发生重绘，重绘不一定发生回流，回流成本更高，改变深层次节点可能导致一系列父节点发生回流。

css优化：
    translate代替top，visibility 代替display:none；
    不要把dom节点属性值放操作放循环里
    避免设置多层内联样式，CSS 选择符从右往左匹配查找
    频繁运行的动画单独加图层（video标签单独加了图层）（position:absolute,fixed）
    不要过多使用table，连带效应。
    避免使用CSS表达式，可能回流

js优化
    避免重复操作样式，（最好一次性重写style，或者将样式列表定义到class并一次性更改class属性）
    避免频繁操作DOM，（创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中）
    避免频繁读取会引起重绘和重排的属性，（使用变量缓存，减少读取次数）