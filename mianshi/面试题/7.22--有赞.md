1. 选择器，以及选择器优先级
!important--->内联-->id--->类/属性/伪类--->元素/伪元素--->关系选择器/通配符选择器


2. 谈谈bfc
是什么：块级格式上下文，一个独立环境，容器这个块box中的布局与容器外的毫无相关。
触发条件：根元素html;
        float值不为none;
        overflow值不为visible,display值为inline-block,table-cell,table-caption;
        position值为absolute或者fixed
特别作用：可以阻止元素被浮动元素覆盖
        可以包含浮动元素
        同个bfc下两个元素会margin重叠，两个不同bfc下的元素margin不会重叠


3. 盒模型
w3c:
width = contentW,
ie情况： width = contentw+border+padding(box-sizing: border-box)


4. 左固定，右适应布局
float:left + margin
calc
float + overflow(开启bfc)
利用flex实现:width + flex:1 


5. 关于跨域
限制一个源的文档或者它加载的脚本如何与另一个源进行交互，即同源策略限制，协议，ip-域名，端口;
无同源策略，接口请求，DOM查询。

我遇到的JSONP,cors,Nginx，postMessage

JSONP只能get,
实现JSONP: 定义获取跨域响应数据的回调函数，并通过没有同源策略限制的script标签发起请求，然后服务端返回该回调函数的执行，并将数据带入回调函数。
JSONP风险：
csrf攻击：将一个网站隐私cookie携带到另外一个网站，被盗取。cookie机制，后端可以设置httpOnly，前端不可操作cookie；
xss漏洞：获取目标网站DOM，盗用信息。（严格定义content-type:application/json,过滤callback参数，进行字符转义，防止脚本    ）

cors:跨域资源共享
1,浏览器请求头加origin
2,服务端配置，Access-Control-Allow-Methods,Access-Control-Allow-Headers,Access-Control-Allow-Origin;指定可访问的方法，头部，源信息
3，请求分为简单和非简单，非简单会先进行探针option方法进行预检，判断是否允许当前跨域请求。

Access-Control-Allow-Origin：要么请求的origin字段，要么*通配符
Access-Control-Allow-Credentials: 是否允许携带cookie
Access-Control-Expose-Headers: cors请求，XMLHttpRequest对象只能拿catch-control,content-language,content-type,expires,last-modifyed,pragma;其他请求头需要单独配置。

postMessage: 
iframe页面嵌入，ifram页面和父页面通信，用到。

6. http2和http1的区别



7. 关于缓存



