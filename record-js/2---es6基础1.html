<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>js问题---2</title>
</head>
<style lang="text/css"></style>
<body>
    
</body>
<script>
var s = 'hello';
/*===========================================================================
1.谈一谈let与var的区别
    1) let命令不存在变量提升，如果在let前使用变量，会导致报错
    2) 如果块区中存在let和const命令，就会形成封闭作用域
    3）不允许重复声明，因此，不能在函数内部重新声明参数

*/
// 暂时性死区
// var tmp = 123;

// if (true) {
//   tmp = 'abc'; // ReferenceError
//   let tmp;
// }






/*===========================================================================
2.map和forEach区别
    1）forEach方法，是最基本的方法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容item、
    数组索引index、和当前遍历数组Array
    2）map方法，基本用法与forEach一致，但是不同的，它会返回一个新的数组，所以在callback需要
    有return值，如果没有，会返回undefined
*/


let a = {
    value: 1
}
function getValue(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value)
}
getValue.call(a, 'yck', '24')
getValue.apply(a, ['yck', '24'])





/*===========================================================================
3.bind、call、apply 区别
    1) call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。
    2) 除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组
    3)bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过
	 bind 实现柯里化
*/







/*===========================================================================
4.如何实现bind,call,apply
*/
Function.prototype.myBind = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  var _this = this
  var args = [...arguments].slice(1)
  // 返回一个函数
  return function F() {
    // 因为返回了一个函数，我们可以 new F()，所以需要判断
    if (this instanceof F) {
      return new _this(...args, ...arguments)
    }
    return _this.apply(context, args.concat(...arguments))
  }
}

Function.prototype.myCall = function (context) {
  var context = context || window
  // 给 context 添加一个属性
  // getValue.call(a, 'yck', '24') => a.fn = getValue
  context.fn = this
  // 将 context 后面的参数取出来
  var args = [...arguments].slice(1)
  // getValue.call(a, 'yck', '24') => a.fn('yck', '24')
  var result = context.fn(...args)
  // 删除 fn
  delete context.fn
  return result
}

Function.prototype.myApply = function (context) {
  var context = context || window
  context.fn = this

  var result
  // 需要判断是否存储第二个参数
  // 如果存在，就将第二个参数展开
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }

  delete context.fn
  return result
}








/*===========================================================================
5. async、await 优缺点
async 和 await 相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准
确的写出代码。缺点在于滥用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后
的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性

    1)首先函数b 先执行，在执行到 await 10 之前变量 a 还是 0，因为在 await 内部实现了 
    generators ，generators 会保留堆栈中东西，所以这时候 a = 0 被保存了下来
    2)因为 await 是异步操作，遇到await就会立即返回一个pending状态的Promise对象，暂
    时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 console.log('1', a)

*/
var a = 0
var b = async () => {
  a = a + await 10
  console.log('2', a) // -> '2' 10
  a = (await 10) + a
  console.log('3', a) // -> '3' 20
}
b()
a++
console.log('1', a) // -> '1' 1


</script>
</html>