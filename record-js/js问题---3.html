<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>js问题---3</title>
</head>
<style lang="text/css"></style>
<body>
    
</body>
<script>
var a;
console.log(a == undefined,undefined==undefined);  //true true    a声明了但未定义
console.log(typeof b);    //undefined    b未声明
console.log(typeof a);   //undefined    
Boolean(undefined)   //false
Number(undefined)   //NaN
String(undefined)   //'undefined'
// console.log(b == undefiend);   //报错  b is not defined
// let b


console.log(null == undefined);//true
Boolean(null)       //false
Number(null)       //0
String(null) 　　  //'null'
console.log(typeof null);//'object'
console.log(null === null);//true
console.log(undefined === null);//false
console.log('null' === null);//false


console.log('iii' == true, 'iii' === true, '' == true, '' === true);//false false false false
console.log(1 == true, 1 === true, 0 == true, 0 === true); //true false false false   注意1==true是true

console.log(NaN == NaN, NaN === NaN);//false false
console.log(isNaN(NaN), isNaN(10), isNaN('10'));//true  false  false
console.log(isNaN('ooo'), isNaN(true));//true   false   //不能转化为数值就是true


/*===========================================================================
1.JavaScript规定了几种语言类型
    1）基本数据类型：number,string,boolean,null,undefined，(新增symbol(ES6)) 
    2）对象类型：Object，（引用类型，还包括 Function 、Array、RegExp、Date 等等。）
    3）typeof 可以区分前面四个基本数据类型，对应：number,string,boolean,object,undefined

    区别：
        1、声明变量时内存分配不同
            原始类型：在栈中，空间固定，存于较小的内存栈中，便于迅速查询。
            引用类型：存在堆中，栈中存储的变量，只是用来查找堆中的引用地址。
            （引用值大小改变，放栈中会降低，但栈中可以存放引用类型得在堆中的地址，因为引用地址大小固定）
        2、不同的内存分配带来不同的访问机制
            js不允许直接访问堆内存中的对象，需要先访问对象在栈内存中的地址，通过地址获取堆中的对象值，
            即引用访问。而基础数据类型可以直接访问。
        3、复制变量不同
            原始类型：原始值变量复制给另一个变量，会把原始值副本给新变量，两个变量独立，只是拥有相同值。
            引用类型：复制的是引用地址，新旧两个变量指向同一个对象，有关联，一个改变，另一个也跟着改变。
        4、传递参数的不同（内存分配的差别）（把实参复制给形参的过程）
            原始类型：变量的值传给参数，之后参数值与变量独立，不影响。
            引用类型：参数是传递的引用对象的地址，参数关联对象，类似（复制情景）

    数据类型： 
    1）undefined：声明的变量但没有初始化时，该变量的值就是undefined
    2)null值表示一个空对象指针，一个特殊的值，常来描述“空值”
        null和undefined往往可以互换，相等运算符“==”是true,
    3)number  特殊数据类型NaN,布尔值是false,NaN与自己不相等。

*/


console.log('=======================================================================');
var Person = function() {
    this.age = 18;
    this.name = 'nihao'
}
var Student = function(){}
Student.prototype = new Person()
var s1 = new Student();
console.log(s1, s1.name, s1.age, s1.sex); //



/*===========================================================================
2.关于原型链
    1）原型：在JavaScript中原型是一个prototype对象，用于表示类型之间的关系。
    2）原型链：js中对象和对象之间存在关系，对象的继承关系，在js中是通过prototype对象指向父类
        对象，直到指向object对象为止，这样形成的原型指向链条就是原型链。
    3）当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的 __proto__
    （即它的构造函数的prototype）中寻找。如果一直找到最上层都没有找到，那么就宣告失败，返回
    undefined。
    4)每个对象都有__proto__属性，此属性指向该对象的构造函数的原型。

*/

console.log('=======================================================================');
console.log(typeof ''); // string 有效
console.log(typeof 1); // number 有效
console.log(typeof Symbol()); // symbol 有效
console.log(typeof true); //boolean 有效
console.log(typeof undefined); //undefined 有效
console.log(typeof null); //object 无效
console.log(typeof [] ); //object 无效
console.log(typeof Function()); // function 有效
console.log(typeof Date()); //string 
console.log(typeof new Date()); //object 无效
console.log(typeof new RegExp()); //object 无效

/*===========================================================================
3.数据类型判断，以及各自优缺点。
    1）typeof  是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。
        包括7 种：number、boolean、symbol、string、object、undefined、function 等
        注意：1> 对于基本类型，除 null 以外，均可以返回正确的结果。
            2>对于引用类型，除 function 以外，一律返回 object 类型。
            3>对于 null ，返回 object 类型。
            4>对于 function 返回 function 类型。
        null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自
        己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型
    2)instanceof


*/


</script>
</html>