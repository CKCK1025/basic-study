<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>js问题---3</title>
</head>
<style lang="text/css"></style>
<body>
    
</body>
<script>
var a;
console.log(a == undefined,undefined==undefined);  //true true    a声明了但未定义
console.log(typeof b);    //undefined    b未声明
console.log(typeof a);   //undefined    
Boolean(undefined)   //false
Number(undefined)   //NaN
String(undefined)   //'undefined'
// console.log(b == undefiend);   //报错  b is not defined
// let b


console.log(null == undefined);//true
Boolean(null)       //false
Number(null)       //0
String(null) 　　  //'null'
console.log(typeof null);//'object'
console.log(null === null);//true
console.log(undefined === null);//false
console.log('null' === null);//false


console.log('iii' == true, 'iii' === true, '' == true, '' === true);//false false false false
console.log(1 == true, 1 === true, 0 == true, 0 === true); //true false false false   注意1==true是true

console.log(NaN == NaN, NaN === NaN);//false false
console.log(isNaN(NaN), isNaN(10), isNaN('10'));//true  false  false
console.log(isNaN('ooo'), isNaN(true));//true   false   //不能转化为数值就是true


/*===========================================================================
1.JavaScript规定了几种语言类型
    1）基本数据类型：number,string,boolean,null,undefined，(新增symbol(ES6)) 
    2）对象类型：Object，（引用类型，还包括 Function 、Array、RegExp、Date 等等。）
    3）typeof 可以区分前面四个基本数据类型，对应：number,string,boolean,object,undefined

    区别：
        1、声明变量时内存分配不同
            原始类型：在栈中，空间固定，存于较小的内存栈中，便于迅速查询。
            引用类型：存在堆中，栈中存储的变量，只是用来查找堆中的引用地址。
            （引用值大小改变，放栈中会降低，但栈中可以存放引用类型得在堆中的地址，因为引用地址大小固定）
        2、不同的内存分配带来不同的访问机制
            js不允许直接访问堆内存中的对象，需要先访问对象在栈内存中的地址，通过地址获取堆中的对象值，
            即引用访问。而基础数据类型可以直接访问。
        3、复制变量不同
            原始类型：原始值变量复制给另一个变量，会把原始值副本给新变量，两个变量独立，只是拥有相同值。
            引用类型：复制的是引用地址，新旧两个变量指向同一个对象，有关联，一个改变，另一个也跟着改变。
        4、传递参数的不同（内存分配的差别）（把实参复制给形参的过程）
            原始类型：变量的值传给参数，之后参数值与变量独立，不影响。
            引用类型：参数是传递的引用对象的地址，参数关联对象，类似（复制情景）

    数据类型： 
    1）undefined：声明的变量但没有初始化时，该变量的值就是undefined
    2)null值表示一个空对象指针，一个特殊的值，常来描述“空值”
        null和undefined往往可以互换，相等运算符“==”是true,
    3)number  特殊数据类型NaN,布尔值是false,NaN与自己不相等。

*/


console.log('=======================================================================');
var Person = function() {
    this.age = 18;
    this.name = 'nihao'
}
var Student = function(){}
Student.prototype = new Person()
var s1 = new Student();
console.log(s1, s1.name, s1.age, s1.sex); //



/*===========================================================================
2.关于原型链
    1）原型：在JavaScript中原型是一个prototype对象，用于表示类型之间的关系。
    2）原型链：js中对象和对象之间存在关系，对象的继承关系，在js中是通过prototype对象指向父类
        对象，直到指向object对象为止，这样形成的原型指向链条就是原型链。
    3）当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的 __proto__
    （即它的构造函数的prototype）中寻找。如果一直找到最上层都没有找到，那么就宣告失败，返回
    undefined。
    4)每个对象都有__proto__属性，此属性指向该对象的构造函数的原型。

*/

console.log('=======================================================================');
console.log(typeof ''); // string 有效
console.log(typeof 1); // number 有效
console.log(typeof Symbol()); // symbol 有效
console.log(typeof true); //boolean 有效
console.log(typeof undefined); //undefined 有效
console.log(typeof null); //object 无效
console.log(typeof [] ); //object 无效
console.log(typeof Function()); // function 有效
console.log(typeof Date()); //string 
console.log(typeof new Date()); //object 无效
console.log(typeof new RegExp()); //object 无效

//模拟 instanceof
function myInstanceof(a,b) {
    var L = a.__proto__;
    var R = b.prototype;
    if(L === R) {
        // A的内部属性 __proto__ 指向 B 的原型对象
        return true;
    }else if (L != 'Object'){

    }
    return false;
}
console.log('myInstanceof==', myInstanceof([], Array)); // true;
console.log('myInstanceof==', myInstanceof([], Object)); // true;
console.log([] instanceof Array); //true
console.log({} instanceof Object);//true
console.log(new Date() instanceof Date);//true
console.log(new RegExp() instanceof RegExp);//true
// console.log(null instanceof Null);//报错
// console.log(undefined instanceof undefined);//报错

let Fn = function f(){}
console.log(Fn.prototype);
var f = new Fn();
console.log(f.constructor == Fn);  //true

Object.prototype.toString.call('') ;   // [object String]
Object.prototype.toString.call(1) ;    // [object Number]
Object.prototype.toString.call(true) ; // [object Boolean]
Object.prototype.toString.call(Symbol()); //[object Symbol]
Object.prototype.toString.call(undefined) ; // [object Undefined]
Object.prototype.toString.call(null) ; // [object Null]
Object.prototype.toString.call(newFunction()) ; // [object Function]
Object.prototype.toString.call(newDate()) ; // [object Date]
Object.prototype.toString.call([]) ; // [object Array]
Object.prototype.toString.call(newRegExp()) ; // [object RegExp]
Object.prototype.toString.call(newError()) ; // [object Error]
Object.prototype.toString.call(document) ; // [object HTMLDocument]
Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用

/*===========================================================================
3.数据类型判断，以及各自优缺点。
    1）typeof  是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。
        包括7 种：number、boolean、symbol、string、object、undefined、function 等
        注意：1> 对于基本类型，除 null 以外，均可以返回正确的结果。
            2>对于引用类型，除 function 以外，一律返回 object 类型。
            3>对于 null ，返回 object 类型。
            4>对于 function 返回 function 类型。
        null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自
        己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型
    2)instanceof 是用来判断 A 是否为 B 的实例 (instanceof 检测的是原型)
        instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属
        于哪种类型。

    3)construtor 当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype
        上添加一个 constructor 属性，并让其指向 F 的引用。
        null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需
        要通过其他方式来判断。
         函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，
         原有的 constructor 引用会丢失，constructor 会默认为 Object
    4)toString toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 
        Object.prototype.toString.call('')
*/









</script>
</html>